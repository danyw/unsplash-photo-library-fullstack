{"ast":null,"code":"var q = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"#\", \"$\", \"%\", \"*\", \"+\", \",\", \"-\", \".\", \":\", \";\", \"=\", \"?\", \"@\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\"],\n  x = t => {\n    let e = 0;\n    for (let r = 0; r < t.length; r++) {\n      let n = t[r],\n        l = q.indexOf(n);\n      e = e * 83 + l;\n    }\n    return e;\n  },\n  p = (t, e) => {\n    var r = \"\";\n    for (let n = 1; n <= e; n++) {\n      let l = Math.floor(t) / Math.pow(83, e - n) % 83;\n      r += q[Math.floor(l)];\n    }\n    return r;\n  };\nvar f = t => {\n    let e = t / 255;\n    return e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n  },\n  h = t => {\n    let e = Math.max(0, Math.min(1, t));\n    return e <= .0031308 ? Math.trunc(e * 12.92 * 255 + .5) : Math.trunc((1.055 * Math.pow(e, .4166666666666667) - .055) * 255 + .5);\n  },\n  F = t => t < 0 ? -1 : 1,\n  M = (t, e) => F(t) * Math.pow(Math.abs(t), e);\nvar d = class extends Error {\n  constructor(e) {\n    super(e), this.name = \"ValidationError\", this.message = e;\n  }\n};\nvar C = t => {\n    if (!t || t.length < 6) throw new d(\"The blurhash string must be at least 6 characters\");\n    let e = x(t[0]),\n      r = Math.floor(e / 9) + 1,\n      n = e % 9 + 1;\n    if (t.length !== 4 + 2 * n * r) throw new d(`blurhash length mismatch: length is ${t.length} but it should be ${4 + 2 * n * r}`);\n  },\n  N = t => {\n    try {\n      C(t);\n    } catch (e) {\n      return {\n        result: !1,\n        errorReason: e.message\n      };\n    }\n    return {\n      result: !0\n    };\n  },\n  z = t => {\n    let e = t >> 16,\n      r = t >> 8 & 255,\n      n = t & 255;\n    return [f(e), f(r), f(n)];\n  },\n  L = (t, e) => {\n    let r = Math.floor(t / 361),\n      n = Math.floor(t / 19) % 19,\n      l = t % 19;\n    return [M((r - 9) / 9, 2) * e, M((n - 9) / 9, 2) * e, M((l - 9) / 9, 2) * e];\n  },\n  U = (t, e, r, n) => {\n    C(t), n = n | 1;\n    let l = x(t[0]),\n      m = Math.floor(l / 9) + 1,\n      b = l % 9 + 1,\n      i = (x(t[1]) + 1) / 166,\n      u = new Array(b * m);\n    for (let o = 0; o < u.length; o++) if (o === 0) {\n      let a = x(t.substring(2, 6));\n      u[o] = z(a);\n    } else {\n      let a = x(t.substring(4 + o * 2, 6 + o * 2));\n      u[o] = L(a, i * n);\n    }\n    let c = e * 4,\n      s = new Uint8ClampedArray(c * r);\n    for (let o = 0; o < r; o++) for (let a = 0; a < e; a++) {\n      let y = 0,\n        B = 0,\n        R = 0;\n      for (let w = 0; w < m; w++) for (let P = 0; P < b; P++) {\n        let G = Math.cos(Math.PI * a * P / e) * Math.cos(Math.PI * o * w / r),\n          T = u[P + w * b];\n        y += T[0] * G, B += T[1] * G, R += T[2] * G;\n      }\n      let V = h(y),\n        I = h(B),\n        E = h(R);\n      s[4 * a + 0 + o * c] = V, s[4 * a + 1 + o * c] = I, s[4 * a + 2 + o * c] = E, s[4 * a + 3 + o * c] = 255;\n    }\n    return s;\n  },\n  j = U;\nvar A = 4,\n  D = (t, e, r, n) => {\n    let l = 0,\n      m = 0,\n      b = 0,\n      g = e * A;\n    for (let u = 0; u < e; u++) {\n      let c = A * u;\n      for (let s = 0; s < r; s++) {\n        let o = c + s * g,\n          a = n(u, s);\n        l += a * f(t[o]), m += a * f(t[o + 1]), b += a * f(t[o + 2]);\n      }\n    }\n    let i = 1 / (e * r);\n    return [l * i, m * i, b * i];\n  },\n  $ = t => {\n    let e = h(t[0]),\n      r = h(t[1]),\n      n = h(t[2]);\n    return (e << 16) + (r << 8) + n;\n  },\n  H = (t, e) => {\n    let r = Math.floor(Math.max(0, Math.min(18, Math.floor(M(t[0] / e, .5) * 9 + 9.5)))),\n      n = Math.floor(Math.max(0, Math.min(18, Math.floor(M(t[1] / e, .5) * 9 + 9.5)))),\n      l = Math.floor(Math.max(0, Math.min(18, Math.floor(M(t[2] / e, .5) * 9 + 9.5))));\n    return r * 19 * 19 + n * 19 + l;\n  },\n  O = (t, e, r, n, l) => {\n    if (n < 1 || n > 9 || l < 1 || l > 9) throw new d(\"BlurHash must have between 1 and 9 components\");\n    if (e * r * 4 !== t.length) throw new d(\"Width and height must match the pixels array\");\n    let m = [];\n    for (let s = 0; s < l; s++) for (let o = 0; o < n; o++) {\n      let a = o == 0 && s == 0 ? 1 : 2,\n        y = D(t, e, r, (B, R) => a * Math.cos(Math.PI * o * B / e) * Math.cos(Math.PI * s * R / r));\n      m.push(y);\n    }\n    let b = m[0],\n      g = m.slice(1),\n      i = \"\",\n      u = n - 1 + (l - 1) * 9;\n    i += p(u, 1);\n    let c;\n    if (g.length > 0) {\n      let s = Math.max(...g.map(a => Math.max(...a))),\n        o = Math.floor(Math.max(0, Math.min(82, Math.floor(s * 166 - .5))));\n      c = (o + 1) / 166, i += p(o, 1);\n    } else c = 1, i += p(0, 1);\n    return i += p($(b), 4), g.forEach(s => {\n      i += p(H(s, c), 2);\n    }), i;\n  },\n  S = O;\nexport { d as ValidationError, j as decode, S as encode, N as isBlurhashValid };","map":{"version":3,"mappings":"AAAA,IAAMA,IAAkB,CACtB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACF;EAEaC,IAAWC,CAAC,IAAgB;IACvC,IAAIC,IAAQ;IACZ,SAASC,IAAI,GAAGA,IAAIF,EAAIG,QAAQD,KAAK;MACnC,IAAME,IAAIJ,EAAIE;QACRG,IAAQP,EAAgBQ,QAAQF,CAAC;MACvCH,IAAQA,IAAQ,KAAKI,CACvB;IAAA;IACA,OAAOJ,CACT;EAAA;EAEaM,IAAW,CAACP,GAAWC,MAA2B;IAC7D,IAAIC,IAAS;IACb,SAASE,IAAI,GAAGA,KAAKH,GAAQG,KAAK;MAChC,IAAIC,IAASG,KAAKC,MAAMT,CAAC,IAAIQ,KAAKE,IAAI,IAAIT,IAASG,CAAC,IAAK;MACzDF,KAAUJ,EAAgBU,KAAKC,MAAMJ,CAAK,EAC5C;IAAA;IACA,OAAOH,CACT;EAAA;ACvGO,IAAMS,IAAeX,CAAC,IAAkB;IAC7C,IAAIC,IAAID,IAAQ;IAChB,OAAIC,KAAK,SACAA,IAAI,QAEJO,KAAKE,IAAK,KAAI,QAAS,OAAO,GAAG,CAE5C;EAAA;EAEaE,IAAeZ,CAAC,IAAkB;IAC7C,IAAIC,IAAIO,KAAKK,IAAI,GAAGL,KAAKM,IAAI,GAAGd,CAAK,CAAC;IACtC,OAAIC,KAAK,WACAO,KAAKO,MAAMd,IAAI,QAAQ,MAAM,EAAG,IAEhCO,KAAKO,MAAO,SAAQP,KAAKE,IAAIT,GAAG,iBAAO,IAAI,QAAS,MAAM,EAAG,CAExE;EAAA;EAEae,IAAOhB,CAAC,IAAeA,IAAI,IAAI,KAAK;EAEpCiB,IAAU,CAACjB,GAAaC,MACnCe,EAAKhB,CAAG,IAAIQ,KAAKE,IAAIF,KAAKU,IAAIlB,CAAG,GAAGC,CAAG;ACrBlC,IAAMkB,IAAN,cAA8BC,KAAM;EACzCC,YAAYpB,GAAiB;IAC3B,MAAMA,CAAO,GACb,KAAKqB,OAAO,mBACZ,KAAKC,UAAUtB,CACjB;EAAA;AACF;ACEA,IAAMuB,IAAmBxB,CAAC,IAAqB;IAC7C,IAAI,CAACA,KAAYA,EAASG,SAAS,GACjC,MAAM,IAAIgB,EACR,mDACF;IAGF,IAAMlB,IAAWF,EAASC,EAAS,EAAE;MAC/BE,IAAOM,KAAKC,MAAMR,IAAW,CAAC,IAAI;MAClCG,IAAQH,IAAW,IAAK;IAE9B,IAAID,EAASG,WAAW,IAAI,IAAIC,IAAOF,GACrC,MAAM,IAAIiB,EACR,uCACEnB,EAASG,2BACU,IAAI,IAAIC,IAAOF,GACtC,CAEJ;EAAA;EAEauB,IAAkBzB,CAC7B,IAC8C;IAC9C,IAAI;MACFwB,EAAiBxB,CAAQ,CAC3B;IAAA,SAASC,GAAP;MACA,OAAO;QAAEyB,QAAQ;QAAOC,aAAa1B,EAAMsB;MAAQ,CACrD;IAAA;IAEA,OAAO;MAAEG,QAAQ;IAAK,CACxB;EAAA;EAEME,IAAW5B,CAAC,IAAkB;IAClC,IAAMC,IAAOD,KAAS;MAChBE,IAAQF,KAAS,IAAK;MACtBI,IAAOJ,IAAQ;IACrB,OAAO,CAACW,EAAaV,CAAI,GAAGU,EAAaT,CAAI,GAAGS,EAAaP,CAAI,CAAC,CACpE;EAAA;EAEMyB,IAAW,CAAC7B,GAAeC,MAAyB;IACxD,IAAMC,IAASM,KAAKC,MAAMT,IAAS,GAAQ;MACrCI,IAASI,KAAKC,MAAMT,IAAQ,EAAE,IAAI;MAClCK,IAASL,IAAQ;IAQvB,OANY,CACViB,EAAS,KAAS,KAAK,GAAG,CAAG,IAAIhB,GACjCgB,EAAS,KAAS,KAAK,GAAG,CAAG,IAAIhB,GACjCgB,EAAS,KAAS,KAAK,GAAG,CAAG,IAAIhB,CACnC,CAGF;EAAA;EAEM6B,IAAS,CACb9B,GACAC,GACAC,GACAE,MACG;IACHoB,EAAiBxB,CAAQ,GAEzBI,IAAQA,IAAQ;IAEhB,IAAMC,IAAWN,EAASC,EAAS,EAAE;MAC/B+B,IAAOvB,KAAKC,MAAMJ,IAAW,CAAC,IAAI;MAClC2B,IAAQ3B,IAAW,IAAK;MAGxB4B,IAAgB,CADQlC,EAASC,EAAS,EAAE,IACJ,KAAK;MAE7CkC,IAAS,IAAIC,MAAMH,IAAOD,CAAI;IAEpC,SAASK,IAAI,GAAGA,IAAIF,EAAO/B,QAAQiC,KACjC,IAAIA,MAAM,GAAG;MACX,IAAMC,IAAQtC,EAASC,EAASsC,UAAU,GAAG,CAAC,CAAC;MAC/CJ,EAAOE,KAAKR,EAASS,CAAK,CAC5B;IAAA,OAAO;MACL,IAAMA,IAAQtC,EAASC,EAASsC,UAAU,IAAIF,IAAI,GAAG,IAAIA,IAAI,CAAC,CAAC;MAC/DF,EAAOE,KAAKP,EAASQ,GAAOJ,IAAe7B,CAAK,CAClD;IAAA;IAGF,IAAMmC,IAActC,IAAQ;MACtBuC,IAAS,IAAIC,kBAAkBF,IAAcrC,CAAM;IAEzD,SAASkC,IAAI,GAAGA,IAAIlC,GAAQkC,KAC1B,SAASC,IAAI,GAAGA,IAAIpC,GAAOoC,KAAK;MAC9B,IAAIK,IAAI;QACJC,IAAI;QACJC,IAAI;MAER,SAASC,IAAI,GAAGA,IAAId,GAAMc,KACxB,SAASC,IAAI,GAAGA,IAAId,GAAMc,KAAK;QAC7B,IAAMC,IACJvC,KAAKwC,IAAKxC,KAAKyC,KAAKZ,IAAIS,IAAK7C,CAAK,IAClCO,KAAKwC,IAAKxC,KAAKyC,KAAKb,IAAIS,IAAK3C,CAAM;UACjCgD,IAAQhB,EAAOY,IAAID,IAAIb;QAC3BU,KAAKQ,EAAM,KAAKH,GAChBJ,KAAKO,EAAM,KAAKH,GAChBH,KAAKM,EAAM,KAAKH,CAClB;MAAA;MAGF,IAAII,IAAOvC,EAAa8B,CAAC;QACrBU,IAAOxC,EAAa+B,CAAC;QACrBU,IAAOzC,EAAagC,CAAC;MAEzBJ,EAAO,IAAIH,IAAI,IAAID,IAAIG,KAAeY,GACtCX,EAAO,IAAIH,IAAI,IAAID,IAAIG,KAAea,GACtCZ,EAAO,IAAIH,IAAI,IAAID,IAAIG,KAAec,GACtCb,EAAO,IAAIH,IAAI,IAAID,IAAIG,KAAe,GACxC;IAAA;IAEF,OAAOC,CACT;EAAA;EAEOc,IAAQxB;ACtHf,IAAMyB,IAAgB;EAEhBC,IAAwB,CAC5BxD,GACAC,GACAC,GACAE,MACkB;IAClB,IAAIC,IAAI;MACJ0B,IAAI;MACJC,IAAI;MACFyB,IAAcxD,IAAQsD;IAE5B,SAASrB,IAAI,GAAGA,IAAIjC,GAAOiC,KAAK;MAC9B,IAAMK,IAAiBgB,IAAgBrB;MAEvC,SAASM,IAAI,GAAGA,IAAItC,GAAQsC,KAAK;QAC/B,IAAMJ,IAAiBG,IAAiBC,IAAIiB;UACtCpB,IAAQjC,EAAc8B,GAAGM,CAAC;QAChCnC,KACEgC,IAAQ1B,EAAaX,EAAOoC,EAAe,GAC7CL,KACEM,IAAQ1B,EAAaX,EAAOoC,IAAiB,EAAE,GACjDJ,KACEK,IAAQ1B,EAAaX,EAAOoC,IAAiB,EAAE,CACnD;MAAA;IACF;IAEA,IAAIH,IAAQ,KAAKhC,IAAQC;IAEzB,OAAO,CAACG,IAAI4B,GAAOF,IAAIE,GAAOD,IAAIC,CAAK,CACzC;EAAA;EAEMyB,IAAW1D,CAAC,IAAiC;IACjD,IAAMC,IAAWW,EAAaZ,EAAM,EAAE;MAChCE,IAAWU,EAAaZ,EAAM,EAAE;MAChCI,IAAWQ,EAAaZ,EAAM,EAAE;IACtC,OAAQ,MAAY,OAAOE,KAAY,KAAKE,CAC9C;EAAA;EAEMuD,IAAW,CAAC3D,GAAsBC,MAAiC;IACvE,IAAIC,IAASM,KAAKC,MAChBD,KAAKK,IACH,GACAL,KAAKM,IAAI,IAAIN,KAAKC,MAAMQ,EAAQjB,EAAM,KAAKC,GAAc,EAAG,IAAI,IAAI,GAAG,CAAC,CAC1E,CACF;MACIG,IAASI,KAAKC,MAChBD,KAAKK,IACH,GACAL,KAAKM,IAAI,IAAIN,KAAKC,MAAMQ,EAAQjB,EAAM,KAAKC,GAAc,EAAG,IAAI,IAAI,GAAG,CAAC,CAC1E,CACF;MACII,IAASG,KAAKC,MAChBD,KAAKK,IACH,GACAL,KAAKM,IAAI,IAAIN,KAAKC,MAAMQ,EAAQjB,EAAM,KAAKC,GAAc,EAAG,IAAI,IAAI,GAAG,CAAC,CAC1E,CACF;IAEA,OAAOC,IAAS,KAAK,KAAKE,IAAS,KAAKC,CAC1C;EAAA;EAEMuD,IAAS,CACb5D,GACAC,GACAC,GACAE,GACAC,MACW;IACX,IAAID,IAAa,KAAKA,IAAa,KAAKC,IAAa,KAAKA,IAAa,GACrE,MAAM,IAAIc,EAAgB,+CAA+C;IAE3E,IAAIlB,IAAQC,IAAS,MAAMF,EAAOG,QAChC,MAAM,IAAIgB,EAAgB,8CAA8C;IAG1E,IAAIY,IAA2C,EAAC;IAChD,SAASS,IAAI,GAAGA,IAAInC,GAAYmC,KAC9B,SAASJ,IAAI,GAAGA,IAAIhC,GAAYgC,KAAK;MACnC,IAAMC,IAAgBD,KAAK,KAAKI,KAAK,IAAI,IAAI;QACvCE,IAASc,EACbxD,GACAC,GACAC,GACA,CAACyC,GAAWC,MACVP,IACA7B,KAAKwC,IAAKxC,KAAKyC,KAAKb,IAAIO,IAAK1C,CAAK,IAClCO,KAAKwC,IAAKxC,KAAKyC,KAAKT,IAAII,IAAK1C,CAAM,CACvC;MACA6B,EAAQ8B,KAAKnB,CAAM,CACrB;IAAA;IAGF,IAAMV,IAAKD,EAAQ;MACb0B,IAAK1B,EAAQ+B,MAAM,CAAC;MAEtB7B,IAAO;MAEPC,IAAW9B,IAAa,IAAK,KAAa,KAAK;IACnD6B,KAAQ1B,EAAS2B,GAAU,CAAC;IAE5B,IAAIK;IACJ,IAAIkB,EAAGtD,SAAS,GAAG;MACjB,IAAIqC,IAAqBhC,KAAKK,IAAI,GAAG4C,EAAGM,IAAI1B,CAAC,IAAQ7B,KAAKK,IAAI,GAAGwB,CAAG,CAAC,CAAC;QAClED,IAAwB5B,KAAKC,MAC/BD,KAAKK,IAAI,GAAGL,KAAKM,IAAI,IAAIN,KAAKC,MAAM+B,IAAqB,MAAM,EAAG,CAAC,CAAC,CACtE;MACAD,IAAgB,KAAwB,KAAK,KAC7CN,KAAQ1B,EAAS6B,GAAuB,CAAC,CAC3C;IAAA,OACEG,IAAe,GACfN,KAAQ1B,EAAS,GAAG,CAAC;IAGvB,YAAQA,EAASmD,EAAS1B,CAAE,GAAG,CAAC,GAEhCyB,EAAGO,QAAQxB,CAAC,IAAW;MACrBP,KAAQ1B,EAASoD,EAASnB,GAAQD,CAAY,GAAG,CAAC,CACpD;IAAA,CAAC,GAEMN,CACT;EAAA;EAEOgC,IAAQL;AAAA","names":["q","x","t","e","r","length","n","l","indexOf","p","Math","floor","pow","f","h","max","min","trunc","F","M","abs","d","Error","constructor","name","message","C","N","result","errorReason","z","L","U","m","b","i","u","Array","o","a","substring","c","s","Uint8ClampedArray","y","B","R","w","P","G","cos","PI","T","V","I","E","j","A","D","g","$","H","O","push","slice","map","forEach","S"],"sources":["C:\\WebDevClasses\\Databases\\Unsplash-FullStack\\client\\node_modules\\blurhash\\src\\base83.ts","C:\\WebDevClasses\\Databases\\Unsplash-FullStack\\client\\node_modules\\blurhash\\src\\utils.ts","C:\\WebDevClasses\\Databases\\Unsplash-FullStack\\client\\node_modules\\blurhash\\src\\error.ts","C:\\WebDevClasses\\Databases\\Unsplash-FullStack\\client\\node_modules\\blurhash\\src\\decode.ts","C:\\WebDevClasses\\Databases\\Unsplash-FullStack\\client\\node_modules\\blurhash\\src\\encode.ts"],"sourcesContent":["const digitCharacters = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"*\",\n  \"+\",\n  \",\",\n  \"-\",\n  \".\",\n  \":\",\n  \";\",\n  \"=\",\n  \"?\",\n  \"@\",\n  \"[\",\n  \"]\",\n  \"^\",\n  \"_\",\n  \"{\",\n  \"|\",\n  \"}\",\n  \"~\",\n];\n\nexport const decode83 = (str: String) => {\n  let value = 0;\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    const digit = digitCharacters.indexOf(c);\n    value = value * 83 + digit;\n  }\n  return value;\n};\n\nexport const encode83 = (n: number, length: number): string => {\n  var result = \"\";\n  for (let i = 1; i <= length; i++) {\n    let digit = (Math.floor(n) / Math.pow(83, length - i)) % 83;\n    result += digitCharacters[Math.floor(digit)];\n  }\n  return result;\n};\n","export const sRGBToLinear = (value: number) => {\n  let v = value / 255;\n  if (v <= 0.04045) {\n    return v / 12.92;\n  } else {\n    return Math.pow((v + 0.055) / 1.055, 2.4);\n  }\n};\n\nexport const linearTosRGB = (value: number) => {\n  let v = Math.max(0, Math.min(1, value));\n  if (v <= 0.0031308) {\n    return Math.trunc(v * 12.92 * 255 + 0.5);\n  } else {\n    return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);\n  }\n};\n\nexport const sign = (n: number) => (n < 0 ? -1 : 1);\n\nexport const signPow = (val: number, exp: number) =>\n  sign(val) * Math.pow(Math.abs(val), exp);\n","export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n    this.message = message;\n  }\n}\n","import { decode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\n/**\n * Returns an error message if invalid or undefined if valid\n * @param blurhash\n */\nconst validateBlurhash = (blurhash: string) => {\n  if (!blurhash || blurhash.length < 6) {\n    throw new ValidationError(\n      \"The blurhash string must be at least 6 characters\"\n    );\n  }\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  if (blurhash.length !== 4 + 2 * numX * numY) {\n    throw new ValidationError(\n      `blurhash length mismatch: length is ${\n        blurhash.length\n      } but it should be ${4 + 2 * numX * numY}`\n    );\n  }\n};\n\nexport const isBlurhashValid = (\n  blurhash: string\n): { result: boolean; errorReason?: string } => {\n  try {\n    validateBlurhash(blurhash);\n  } catch (error) {\n    return { result: false, errorReason: error.message };\n  }\n\n  return { result: true };\n};\n\nconst decodeDC = (value: number) => {\n  const intR = value >> 16;\n  const intG = (value >> 8) & 255;\n  const intB = value & 255;\n  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];\n};\n\nconst decodeAC = (value: number, maximumValue: number) => {\n  const quantR = Math.floor(value / (19 * 19));\n  const quantG = Math.floor(value / 19) % 19;\n  const quantB = value % 19;\n\n  const rgb = [\n    signPow((quantR - 9) / 9, 2.0) * maximumValue,\n    signPow((quantG - 9) / 9, 2.0) * maximumValue,\n    signPow((quantB - 9) / 9, 2.0) * maximumValue,\n  ];\n\n  return rgb;\n};\n\nconst decode = (\n  blurhash: string,\n  width: number,\n  height: number,\n  punch?: number\n) => {\n  validateBlurhash(blurhash);\n\n  punch = punch | 1;\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  const quantisedMaximumValue = decode83(blurhash[1]);\n  const maximumValue = (quantisedMaximumValue + 1) / 166;\n\n  const colors = new Array(numX * numY);\n\n  for (let i = 0; i < colors.length; i++) {\n    if (i === 0) {\n      const value = decode83(blurhash.substring(2, 6));\n      colors[i] = decodeDC(value);\n    } else {\n      const value = decode83(blurhash.substring(4 + i * 2, 6 + i * 2));\n      colors[i] = decodeAC(value, maximumValue * punch);\n    }\n  }\n\n  const bytesPerRow = width * 4;\n  const pixels = new Uint8ClampedArray(bytesPerRow * height);\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0;\n      let g = 0;\n      let b = 0;\n\n      for (let j = 0; j < numY; j++) {\n        for (let i = 0; i < numX; i++) {\n          const basis =\n            Math.cos((Math.PI * x * i) / width) *\n            Math.cos((Math.PI * y * j) / height);\n          let color = colors[i + j * numX];\n          r += color[0] * basis;\n          g += color[1] * basis;\n          b += color[2] * basis;\n        }\n      }\n\n      let intR = linearTosRGB(r);\n      let intG = linearTosRGB(g);\n      let intB = linearTosRGB(b);\n\n      pixels[4 * x + 0 + y * bytesPerRow] = intR;\n      pixels[4 * x + 1 + y * bytesPerRow] = intG;\n      pixels[4 * x + 2 + y * bytesPerRow] = intB;\n      pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha\n    }\n  }\n  return pixels;\n};\n\nexport default decode;\n","import { encode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\ntype NumberTriplet = [number, number, number];\n\nconst bytesPerPixel = 4;\n\nconst multiplyBasisFunction = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  basisFunction: (i: number, j: number) => number\n): NumberTriplet => {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  const bytesPerRow = width * bytesPerPixel;\n\n  for (let x = 0; x < width; x++) {\n    const bytesPerPixelX = bytesPerPixel * x;\n\n    for (let y = 0; y < height; y++) {\n      const basePixelIndex = bytesPerPixelX + y * bytesPerRow;\n      const basis = basisFunction(x, y);\n      r +=\n        basis * sRGBToLinear(pixels[basePixelIndex]);\n      g +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 1]);\n      b +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 2]);\n    }\n  }\n\n  let scale = 1 / (width * height);\n\n  return [r * scale, g * scale, b * scale];\n};\n\nconst encodeDC = (value: NumberTriplet): number => {\n  const roundedR = linearTosRGB(value[0]);\n  const roundedG = linearTosRGB(value[1]);\n  const roundedB = linearTosRGB(value[2]);\n  return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\n\nconst encodeAC = (value: NumberTriplet, maximumValue: number): number => {\n  let quantR = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantG = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantB = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n\n  return quantR * 19 * 19 + quantG * 19 + quantB;\n};\n\nconst encode = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  componentX: number,\n  componentY: number\n): string => {\n  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n    throw new ValidationError(\"BlurHash must have between 1 and 9 components\");\n  }\n  if (width * height * 4 !== pixels.length) {\n    throw new ValidationError(\"Width and height must match the pixels array\");\n  }\n\n  let factors: Array<[number, number, number]> = [];\n  for (let y = 0; y < componentY; y++) {\n    for (let x = 0; x < componentX; x++) {\n      const normalisation = x == 0 && y == 0 ? 1 : 2;\n      const factor = multiplyBasisFunction(\n        pixels,\n        width,\n        height,\n        (i: number, j: number) =>\n          normalisation *\n          Math.cos((Math.PI * x * i) / width) *\n          Math.cos((Math.PI * y * j) / height)\n      );\n      factors.push(factor);\n    }\n  }\n\n  const dc = factors[0];\n  const ac = factors.slice(1);\n\n  let hash = \"\";\n\n  let sizeFlag = componentX - 1 + (componentY - 1) * 9;\n  hash += encode83(sizeFlag, 1);\n\n  let maximumValue: number;\n  if (ac.length > 0) {\n    let actualMaximumValue = Math.max(...ac.map((val) => Math.max(...val)));\n    let quantisedMaximumValue = Math.floor(\n      Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5)))\n    );\n    maximumValue = (quantisedMaximumValue + 1) / 166;\n    hash += encode83(quantisedMaximumValue, 1);\n  } else {\n    maximumValue = 1;\n    hash += encode83(0, 1);\n  }\n\n  hash += encode83(encodeDC(dc), 4);\n\n  ac.forEach((factor) => {\n    hash += encode83(encodeAC(factor, maximumValue), 2);\n  });\n\n  return hash;\n};\n\nexport default encode;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}